{"version":3,"sources":["webpack:///./customHooks/useQuery.js","webpack:///./routes/ViewerRouting.js","webpack:///./customHooks/usePrevious.js","webpack:///./googleCloud/api/GoogleCloudApi.js","webpack:///C:/sandbox/Viewers/node_modules/lodash/_baseValues.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///C:/sandbox/Viewers/node_modules/lodash/values.js","webpack:///./googleCloud/utils/getServers.js","webpack:///./customHooks/useServer.js"],"names":["URLSearchParams","useLocation","search","UrlUtil","utils","urlUtil","getSeriesInstanceUIDs","seriesInstanceUIDs","routeLocation","queryFilters","queryString","getQueryFilters","querySeriesUIDs","_seriesInstanceUIDs","paramString","parseParam","ViewerRouting","routeMatch","match","location","params","project","dataset","dicomStore","studyInstanceUIDs","authToken","useQuery","get","user","getAccessToken","server","useServer","studyUIDs","seriesUIDs","ConnectedViewerRetrieveStudyData","propTypes","PropTypes","shape","string","isRequired","any","usePrevious","value","ref","useRef","useEffect","current","GoogleCloudApi","accessToken","console","error","this","urlBase","urlStr","config","url","URL","data","fetch","fetchConfig","response","json","status","nextPageToken","pageToken","doRequest","key","subPage","hasOwnProperty","concat","isError","message","projectId","urlBaseProject","locationId","Error","method","headers","Authorization","healthcareApiEndpoint","arrayMap","module","exports","object","props","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_sortStudyDisplaySet","_promoteStudyDisplaySet","Object","keys","length","seriesInstanceUID","promotedResponse","list","searchMethod","index","findIndex","bind","undefined","first","splice","_promoteToFront","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","displaySets","_isQueryParamApplied","applied","series","firstSeries","_showUserMessage","queryParamApplied","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","add","_updateStudyDisplaySets","createDisplaySets","_addDerivedDisplaySets","setDisplaySets","sortDisplaySets","_thinStudyData","map","item","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","clearViewportSpecificData","setStudyData","useState","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","log","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","every","e","includes","purge","JSON","stringify","ConnectedViewer","array","func","OHIF","redux","actions","isActive","a","active","connect","state","ownProps","activeServer","servers","find","dispatch","baseValues","getServers","name","wadoUriRoot","qidoRoot","wadoRoot","imageRendering","thumbnailRendering","type","supportsFuzzyMatching","qidoSupportsIncludeField","isValidServer","isEqualServer","toCompare","serverLength","toCompareLength","getActiveServer","enableGoogleCloudAdapter","pathUrl","getUrlBaseDicomWeb","GoogleCloudUtilServers","setServers","useServerFromUrl","previousServers","urlBasedServers","serverHasChanged","newServer","exists","some","useSelector","useDispatch"],"mappings":"gLAQe,aACb,OAAO,IAAIA,gBAAgBC,cAAcC,SCF1BC,EAAYC,IAArBC,QAOFC,EAAwB,SAACC,EAAoBC,GACjD,IAAMC,EAAeN,EAAQO,YAAYC,gBAAgBH,GACnDI,EAAkBH,GAAgBA,EAAY,kBAC9CI,EAAsBN,GAAsBK,EAElD,OAAOT,EAAQW,YAAYC,WAAWF,IAGxC,SAASG,EAAT,GAAuE,IAAvCC,EAAuC,EAA9CC,MAA6BV,EAAiB,EAA3BW,SAA2B,EAQjEF,EAAWG,OANbC,EAFmE,EAEnEA,QACAF,EAHmE,EAGnEA,SACAG,EAJmE,EAInEA,QACAC,EALmE,EAKnEA,WACAC,EANmE,EAMnEA,kBACAjB,EAPmE,EAOnEA,mBAQIkB,EADMC,IACYC,IAAI,SAExBF,IACFG,IAAKC,eAAiB,kBAAMJ,IAG9B,IAAMK,EAASC,YAAU,CAAEV,UAASF,WAAUG,UAASC,eACjDS,EAAY7B,EAAQW,YAAYC,WAAWS,GAC3CS,EAAa3B,EAAsBC,EAAoBC,GAE7D,OAAIsB,GAAUE,EAEV,kBAACE,EAAA,EAAD,CACEV,kBAAmBQ,EACnBzB,mBAAoB0B,IAKnB,KAGTjB,EAAcmB,UAAY,CACxBjB,MAAOkB,IAAUC,MAAM,CACrBjB,OAAQgB,IAAUC,MAAM,CACtBb,kBAAmBY,IAAUE,OAAOC,WACpChC,mBAAoB6B,IAAUE,OAC9BhB,QAASc,IAAUE,OACnBf,WAAYa,IAAUE,OACtBnB,SAAUiB,IAAUE,OACpBjB,QAASe,IAAUE,WAGvBnB,SAAUiB,IAAUI,KAGPxB,a,iCCzEf,6CACe,SAASyB,EAAYC,GAClC,IAAMC,EAAMC,mBAKZ,OAJAC,qBAAU,WACRF,EAAIG,QAAUJ,IACb,CAACA,IAEGC,EAAIG,U,8qCCPPC,E,sMACWC,GACRA,GAAaC,QAAQC,MAAM,yBAChCC,KAAKH,YAAcA,I,yCAyBF3B,EAASF,EAAUG,EAASC,GAC7C,OACE4B,KAAKC,QAAL,oBACa/B,EADb,sBACkCF,EADlC,qBACuDG,EADvD,wBAC8EC,EAD9E,e,iCAKOF,EAASF,EAAUG,EAASC,GACrC,oBAAaF,EAAb,sBAAkCF,EAAlC,qBAAuDG,EAAvD,wBAA8EC,K,gEAGhE8B,G,qHAAQC,E,+BAAS,GAAIlC,E,+BAAS,GACtCmC,EAAM,IAAIC,IAAIH,GAChBI,EAAO,KACXF,EAAIrD,OAAS,IAAIF,gBAAgBoB,G,kBAGRsC,MAAMH,EAAD,KAAWJ,KAAKQ,YAAhB,CAA6BL,Y,cAAnDM,E,0BAESA,EAASC,O,QAAtBJ,E,sEAEEG,EAASE,QAAU,KAAOF,EAASE,OAAS,KAAe,MAARL,G,oBAC3B,MAAtBA,EAAKM,c,wBACP3C,EAAO4C,UAAYP,EAAKM,c,UACJZ,KAAKc,UAAUZ,EAAQC,EAAQlC,G,QACnD,IAAS8C,KADLC,E,OACYV,EACVA,EAAKW,eAAeF,KACtBT,EAAKS,GAAOT,EAAKS,GAAKG,OAAOF,EAAQV,KAAKS,K,iCAIzC,CACLI,SAAS,EACTR,OAAQF,EAASE,OACjBL,S,iCAGK,CACLa,SAAS,EACTR,OAAQF,EAASE,OACjBS,QACGd,GAAQA,EAAKP,OAASO,EAAKP,MAAMqB,SAAY,kB,8DAIhDd,IAAQA,EAAKP,M,0CACR,CACLoB,SAAS,EACTR,OAAQ,KAAIA,OACZS,QAAS,KAAIX,SAASH,KAAKP,MAAMqB,SAAW,sB,iCAGzC,CACLD,SAAS,EACTC,QAAU,MAAO,KAAIA,SAAY,+B,6RAM9BpB,KAAKc,UACV,4D,iKAIgBO,G,yGACXrB,KAAKc,UAAL,UAAkBd,KAAKsB,eAAvB,YAAyCD,EAAzC,gB,iKAGUA,EAAWE,G,yGACrBvB,KAAKc,UAAL,UACFd,KAAKsB,eADH,YACqBD,EADrB,sBAC4CE,EAD5C,e,sKAKapD,G,yGACb6B,KAAKc,UAAL,UAAkBd,KAAKC,QAAvB,YAAkC9B,EAAlC,kB,gIAjGP,IAAK6B,KAAKH,YAAa,MAAM,IAAI2B,MAAM,gCACvC,MAAO,CACLC,OAAQ,MACRC,QAAS,CACPC,cAAe,UAAY3B,KAAKH,gB,8BAMpC,OAAOG,KAAK4B,uBAAyB,6C,aAG3BxB,GACVJ,KAAK4B,sBAAwBxB,I,qCAI7B,OAAOJ,KAAKC,QAAL,iB,gCAmFI,QAAIL,G,oBC5GnB,IAAIiC,EAAW,EAAQ,KAkBvBC,EAAOC,QANP,SAAoBC,EAAQC,GAC1B,OAAOJ,EAASI,GAAO,SAASlB,GAC9B,OAAOiB,EAAOjB,Q,oyCCFVmB,EAA0CC,IAA1CD,kBAAmBE,EAAuBD,IAAvBC,mBACnBC,EAAwDC,IAAxDD,wBAAyBE,EAA+BD,IAA/BC,2BACzBC,EAAyCvF,IAAzCuF,qBAAsBC,EAAmBxF,IAAnBwF,eA6BxBC,EAAe,SAACC,EAAOC,EAAeC,EAASC,GACnD,IAAIC,GAAW,EAOf,OALKD,IACHE,EAAqBL,EAAOC,GAC5BG,EAAWE,EAAwBN,EAAOC,EAAeC,IAGpDE,GAGHE,EAA0B,SAACN,EAAOC,EAAeC,GACrD,IAAIE,GAAW,EAIf,GAH0BG,OAAOC,KAAKN,GAASO,OACE,EAEvB,KAChBC,EAAsBR,EAAtBQ,kBAKFC,EAjDc,SAACC,EAAMhE,EAAOiE,GACpC,IAAI/C,EAAW,EAAI8C,GACfR,GAAW,EACTU,EAAQhD,EAASiD,UAAUF,EAAaG,UAAKC,EAAWrE,IAE9D,GAAIkE,EAAQ,EAAG,CACb,IAAMI,EAAQpD,EAASqD,OAAOL,EAAO,GACrChD,EAAW,GAAH,SAAOoD,GAAP,EAAiBpD,IAO3B,OAJIgD,GAAS,IACXV,GAAW,GAGN,CACLA,WACAzC,KAAMG,GAiCmBsD,CACvBnB,EAAcoB,iBACdX,GALoB,SAACY,EAAgBC,GACrC,OAAOA,EAAWC,oBAAsBF,KAQ1CtB,EAAMyB,YAAcd,EAAiBhD,KACrCyC,EAAWO,EAAiBP,SAG9B,OAAOA,GAUHsB,EAAuB,SAAC1B,GAA0C,IAAnCE,EAAmC,uDAAzB,GAAIC,EAAqB,uCAC9DO,EAAsBR,EAAtBQ,kBACJiB,GAAU,EAEd,IAAKjB,EACH,OAAOiB,EAL6D,MAQ5B3B,EAAlC4B,cAR8D,MAQrD,GARqD,IAQ5B5B,EAArByB,mBARiD,MAQnC,GARmC,EAShEI,EAAc1B,EAAmByB,EAAO,GAAKH,EAAY,GAM/D,OAJKI,GAAeA,EAAYL,oBAAsBd,IACpDiB,GAAU,GAGLA,GAEHG,EAAmB,SAACC,EAAmBtD,GAAyB,IAAhBuD,EAAgB,uDAAP,GAC7D,IAAID,EAAJ,CADoE,MAKvBC,EAArCC,KAAMC,OALsD,MAKpC,aALoC,EAMpEA,EAAgB,CACdzD,cAIE0D,EAAoB,SAAClC,EAAe2B,GACxC,IAAMQ,EACJC,IAAiBC,QAAjB,sBACItC,EAAQC,EAAcsC,UACtBC,EAAiB,IAAI/C,EAAmBmC,EAAQ5B,GAC/BC,EAAcwC,eAAeb,EAAOJ,mBAEzDvB,EAAcyC,aAAad,EAAOJ,kBAAmBgB,GAErDvC,EAAc0C,UAAUH,GAG1BvC,EAAc2C,iCACZR,EACAI,GAGFxC,EAAMyB,YAAcxB,EAAcoB,iBAClCrB,EAAM6C,mBAAqB5C,EAAc6C,mBAAmB,CAC1DC,SAAUnB,EAAOmB,WAGnBC,EAA4BhD,EAAOC,IAG/B+C,EAA8B,SAAChD,EAAOC,GAAkB,IACpDgD,EAAqBjD,EAArBiD,iBAEHpD,EAAqBhE,IAAIoH,IAC5BpD,EAAqBqD,IAAIjD,IAIvBkD,EAA0B,SAACnD,EAAOC,GACtC,IAAMmC,EACJC,IAAiBC,QAAjB,sBAEGtC,EAAMyB,cACTzB,EAAMyB,YAAcxB,EAAcmD,kBAAkBhB,IAGlDpC,EAAM6C,oBACR5C,EAAcoD,uBAAuBrD,EAAM6C,oBAG7C5C,EAAcqD,eAAetD,EAAMyB,cAG/BpB,EAAuB,SAACL,EAAOC,GACnCA,EAAcsD,gBAAgBvD,EAAMyB,cAGhC+B,EAAiB,SAAAxD,GACrB,MAAO,CACLiD,iBAAkBjD,EAAMiD,iBACxBrB,OAAQ5B,EAAM4B,OAAO6B,KAAI,SAAAC,GAAI,MAAK,CAChClC,kBAAmBkC,EAAKlC,wBAK9B,SAASmC,EAAT,GAMG,IAYGC,EACAC,EAlBJ7H,EAKC,EALDA,OACAN,EAIC,EAJDA,kBACAjB,EAGC,EAHDA,mBACAqJ,EAEC,EAFDA,0BACAC,EACC,EADDA,aACC,IAEyBC,oBAAS,GAFlC,GAEM5G,EAFN,KAEa6G,EAFb,SAG6BD,mBAAS,IAHtC,GAGMrE,EAHN,KAGeuE,EAHf,SAIyCF,oBAAS,GAJlD,GAIMG,EAJN,KAIqBC,EAJrB,KAKKC,EAAkBC,cALvB,EAM0BC,qBAAWC,KAA9BC,iBANP,MAMmB,GANnB,IAUGA,EAFFC,iBAAkBvE,OARnB,SASCwE,EACEF,EADFE,8BAgDIC,EAAiB,SAACC,EAAa3E,GACnC,GAAI4E,MAAMC,QAAQF,IAAgBA,EAAYpE,OAAS,EAAG,CAExD,IAAMd,EAAUkF,EAAYpB,KAAI,SAAAzD,GAC9B+D,EAAa/D,EAAMiD,iBAAkBO,EAAexD,IACpD,IAAMC,EAAgB,IAAIV,EACxBS,EACAA,EAAMiD,kBAsBR,OAnBAE,EAAwBnD,EAAOC,GAC/B+C,EAA4BhD,EAAOC,GAGnC2D,EAAyB5D,EAAMiD,kBAAoBnD,EACjDkF,EAAoB/E,IAEnBgF,MAAK,SAAAC,GACAA,IAAWA,EAAOC,YAtDX,SAACnF,EAAOC,EAAeC,GAEzBH,EACfC,EACAC,EACAC,EACAC,IAKA2D,EAA0B,GAG5B,IAAMsB,EAAsB1D,EAC1B1B,EACAE,EACAC,GAGF2B,EACEsD,EACA,iFACAf,GAGFH,EAAW,GAAD,SAAKvE,GAAL,CAAcK,KACxBoE,GAAiB,GA4BPiB,CAAarF,EAAOC,EAAeC,MAGtCoF,OAAM,SAAAlI,GACDA,IAAUA,EAAM+H,aAClBlB,GAAS,GACTsB,IAAInI,MAAMA,OAIT4C,KAGTkE,EAAWvE,KAMTqF,EAAmB,4CAAG,WAAM/E,GAAN,mGACDA,EAAcsC,UAA/BiD,EADkB,EAClBA,aADkB,wDAIpBC,EAJoB,4CAIH,sGAChBD,EAAaE,UADG,iEAEAF,EAAaG,OAFb,cAEf/D,EAFe,OAGrBO,EAAkBlC,EAAe2B,GATTsC,GAAW,SAAAvE,GAAO,SAAQA,MAM7B,kBAKd8F,KALc,2CAJG,qDAYpBG,EACJjB,GAAiC1E,EAAc4F,iBAC3CC,EAAWhB,MAAMc,GACpBG,KAAK,MACLtC,IAAIgC,GAhBmB,SAkBbO,QAAQC,IAAIH,GAlBC,mFAAH,sDAqBnBI,EAAW,4CAAG,uGAClB,IACQhG,EAAU,GAEVQ,EAAoBjG,GAAsBA,EAAmB,GAE7D0L,EAAiB,CAACnK,EAAQN,GAE5BgF,IACFR,EAAQQ,kBAAoBA,EAExBP,GACFgG,EAAeC,KAAKlG,IAIxB2D,EAA0BnI,GAAqBoE,EAC7CJ,EAAuB,WAAvB,EAA2ByG,IAE1BlB,MAAK,SAAAC,GACAA,IAAWA,EAAOC,YACpBP,EAAeM,EAAQhF,MAG1BoF,OAAM,SAAAlI,GACDA,IAAUA,EAAM+H,aAClBlB,GAAS,GACTsB,IAAInI,MAAMA,OAGhB,MAAOA,GACHA,IACF6G,GAAS,GACTsB,IAAInI,MAAMA,IAjCI,2CAAH,qDAsCXiJ,EAA2BC,uBAAY,WAC3C,IAAK,IAAI5K,KAAqBmI,EACxB,WAAYA,EAA0BnI,IACxCmI,EAA0BnI,GAAmB6K,SAIjD,IAAK,IAAI7K,KAAqBkI,EACxB,WAAYA,EAAyBlI,KACvCkI,EAAyBlI,GAAmB6K,SAC5C3G,EAA2BlE,GAC3BmE,EAAqB2G,OAAO9K,OAK5B+K,EAAwB9J,YAAYjB,GAwB1C,OAtBAqB,qBAAU,aAEN0J,GACAA,EAAsBC,OAAM,SAAAC,GAAC,OAAIjL,EAAkBkL,SAASD,SAI5D9G,EAAqBgH,QACrBR,OAED,CAACI,EAAuBJ,EAA0B3K,IAErDqB,qBAAU,WAKR,OAJA6G,EAA2B,GAC3BC,EAA4B,GAC5BqC,IAEO,WACLG,OAED,IAECjJ,EACK,uCAAa0J,KAAKC,UAAU3J,IAInC,kBAAC4J,EAAA,EAAD,CACErH,QAASA,EACTwE,cAAeA,EACfzI,kBAAmBA,IAKzBiI,EAAwBtH,UAAY,CAClCX,kBAAmBY,IAAU2K,MAAMxK,WACnChC,mBAAoB6B,IAAU2K,MAC9BjL,OAAQM,IAAU+C,OAClByE,0BAA2BxH,IAAU4K,KAAKzK,WAC1CsH,aAAczH,IAAU4K,KAAKzK,YAGhBkH,Q,QCvYqCwD,EAAKC,MAAMC,QAAvDvD,E,EAAAA,0BAA2BC,E,EAAAA,aAC7BuD,EAAW,SAAAC,GAAC,OAAiB,IAAbA,EAAEC,QAoBlBpL,EAAmCqL,aAlBjB,SAACC,EAAOC,GAC9B,IAAMC,EAAeF,EAAMG,QAAQA,QAAQC,KAAKR,GAEhD,MAAO,CACLtL,OAAQ2L,EAAS3L,QAAU4L,MAGJ,SAAAG,GACzB,MAAO,CACLhE,aAAc,SAACd,EAAkBtF,GAC/BoK,EAAShE,EAAad,EAAkBtF,KAE1CmG,0BAA2B,WACzBiE,EAASjE,SAK0B2D,CAGvC9D,GAEavH,O,oBC9Bf,IAAI4L,EAAa,EAAQ,KACrBxH,EAAO,EAAQ,KAgCnBrB,EAAOC,QAJP,SAAgBC,GACd,OAAiB,MAAVA,EAAiB,GAAK2I,EAAW3I,EAAQmB,EAAKnB,M,iCC9BvD,0GAAM4I,EAAa,SAACtK,EAAMuK,GAAS,IAE/BC,EAOExK,EAPFwK,YACAC,EAMEzK,EANFyK,SACAC,EAKE1K,EALF0K,SAJ+B,EAS7B1K,EAJFnC,eAL+B,MAKrB,GALqB,IAS7BmC,EAHFlC,kBAN+B,MAMlB,GANkB,IAS7BkC,EAFFtC,gBAP+B,MAOpB,GAPoB,IAS7BsC,EADFpC,QAGF,MAAO,CACL,CACE2M,KAAMA,EACN1M,UACAC,aACAJ,WACAE,aAjB6B,MAQrB,GARqB,EAkB7B+M,eAAgB,SAChBC,mBAAoB,SACpBC,KAAM,WACNhB,QAAQ,EACRW,cACAC,WACAC,WACAI,uBAAuB,EACvBC,0BAA0B,KAK1BC,EAAgB,SAAA3M,GACpB,OACEA,KACEA,EAAOR,WACPQ,EAAOP,cACPO,EAAOX,YACPW,EAAOT,SAIPqN,EAAgB,WAAiC,IAAhC5M,EAAgC,uDAAvB,GAAI6M,EAAmB,uDAAP,GACxCC,EAAevI,OAAOC,KAAKxE,GAAQyE,OACnCsI,EAAkBxI,OAAOC,KAAKqI,GAAWpI,OAE/C,SAAKqI,IAAiBC,KAKpB/M,EAAOR,UAAYqN,EAAUrN,SAC7BQ,EAAOR,UAAYqN,EAAUrN,SAC7BQ,EAAOP,aAAeoN,EAAUpN,YAChCO,EAAOX,WAAawN,EAAUxN,UAC9BW,EAAOT,UAAYsN,EAAUtN,W,iCCtDjC,iGAWMyN,EAAkB,SAAAnB,GAGtB,OAAOA,GAAWA,EAAQA,SAAWA,EAAQA,QAAQC,MAFpC,SAAAP,GAAC,OAAiB,IAAbA,EAAEC,WAKpBS,EAAa,SAACxD,EAAWlJ,EAASF,EAAUG,EAASC,GACzD,IAAIoM,EAAU,GACd,GAAIpD,EAAUwE,yBAA0B,CACtChM,IAAeK,QAAUmH,EAAUxF,sBACnC,IAAMiK,EAAUjM,IAAekM,mBAC7B5N,EACAF,EACAG,EACAC,GAEIkC,EAAO,CACXpC,UACAF,WACAG,UACAC,aACA0M,YAAae,EACbd,SAAUc,EACVb,SAAUa,GAGZ,GADArB,EAAUuB,IAAkCzL,EAAMlC,IAC7CkN,EAAcd,EAAQ,GAAIpD,GAC7B,OAIJ,OAAOoD,GAGHc,EAAgB,SAAC3M,EAAQyI,GAC7B,OAAIA,EAAUwE,yBACLG,IAAqCpN,KAGrCA,GAGLqN,EAAa,SAACtB,EAAUF,GAK5BE,EAJe,CACbS,KAAM,cACNX,aAKEyB,EAAmB,WAUpB,IATHzB,EASG,uDATO,GACV0B,EAQG,uCAPH3B,EAOG,uCANH4B,EAMG,uCALH/E,EAKG,2KAEH,IAAKA,EAAUwE,yBACb,OAAO,EAGT,IAAMQ,EAAmBF,IAAoB1B,GAAW0B,EAGxD,GAAIE,EACF,OAAO,EAIT,IAAKD,IAAoBA,EAAgB/I,OACvC,OAAO,EACF,IAAKoH,EAAQpH,SAAWmH,EAE7B,OAAO,EAGT,IAAM8B,EAAYF,EAAgB,GAE9BG,EAAS9B,EAAQ+B,KACnBR,IAAqCpI,UAAKC,EAAWyI,IAGvD,OAAQC,GAGK,SAAS1N,IAKhB,6DAAJ,GAJFV,EAIM,EAJNA,QACAF,EAGM,EAHNA,SACAG,EAEM,EAFNA,QACAC,EACM,EADNA,WAGMoM,EAAUgC,aAAY,SAAAnC,GAAK,OAAIA,GAASA,EAAMG,WAC9C0B,EAAkB5M,YAAYkL,GAC9BE,EAAW+B,cAJX,EAMqBvF,qBAAWC,KAA9BC,iBANF,MAMc,GANd,EAQAmD,EAAeoB,EAAgBnB,GAC/B2B,EACJvB,EAAWxD,EAAWlJ,EAASF,EAAUG,EAASC,IAAe,GAanE,GAZ2B6N,EACzBzB,EAAQA,QACR0B,EACA3B,EACA4B,EACA/E,EACAlJ,EACAF,EACAG,EACAC,GAIA4N,EAAWtB,EAAUyB,QAChB,GAAIb,EAAcf,EAAcnD,GACrC,OAAOmD","file":"ViewerRouting.bundle.c5acb46020dc545f5d0e.js","sourcesContent":["import { useLocation } from 'react-router-dom';\r\n\r\n/**\r\n * hook that builds on useLocation to parse\r\n * the query string for you.\r\n *\r\n * @name useQuery\r\n */\r\nexport default function() {\r\n  return new URLSearchParams(useLocation().search);\r\n}\r\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { utils, user } from '@ohif/core';\r\n//\r\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData';\r\nimport useServer from '../customHooks/useServer';\r\nimport useQuery from '../customHooks/useQuery';\r\nconst { urlUtil: UrlUtil } = utils;\r\n\r\n/**\r\n * Get array of seriesUIDs from param or from queryString\r\n * @param {*} seriesInstanceUIDs\r\n * @param {*} location\r\n */\r\nconst getSeriesInstanceUIDs = (seriesInstanceUIDs, routeLocation) => {\r\n  const queryFilters = UrlUtil.queryString.getQueryFilters(routeLocation);\r\n  const querySeriesUIDs = queryFilters && queryFilters['seriesInstanceUID'];\r\n  const _seriesInstanceUIDs = seriesInstanceUIDs || querySeriesUIDs;\r\n\r\n  return UrlUtil.paramString.parseParam(_seriesInstanceUIDs);\r\n};\r\n\r\nfunction ViewerRouting({ match: routeMatch, location: routeLocation }) {\r\n  const {\r\n    project,\r\n    location,\r\n    dataset,\r\n    dicomStore,\r\n    studyInstanceUIDs,\r\n    seriesInstanceUIDs,\r\n  } = routeMatch.params;\r\n\r\n  // Set the user's default authToken for outbound DICOMWeb requests.\r\n  // Is only applied if target server does not set `requestOptions` property.\r\n  //\r\n  // See: `getAuthorizationHeaders.js`\r\n  let query = useQuery();\r\n  const authToken = query.get('token');\r\n\r\n  if (authToken) {\r\n    user.getAccessToken = () => authToken;\r\n  }\r\n\r\n  const server = useServer({ project, location, dataset, dicomStore });\r\n  const studyUIDs = UrlUtil.paramString.parseParam(studyInstanceUIDs);\r\n  const seriesUIDs = getSeriesInstanceUIDs(seriesInstanceUIDs, routeLocation);\r\n\r\n  if (server && studyUIDs) {\r\n    return (\r\n      <ConnectedViewerRetrieveStudyData\r\n        studyInstanceUIDs={studyUIDs}\r\n        seriesInstanceUIDs={seriesUIDs}\r\n      />\r\n    );\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nViewerRouting.propTypes = {\r\n  match: PropTypes.shape({\r\n    params: PropTypes.shape({\r\n      studyInstanceUIDs: PropTypes.string.isRequired,\r\n      seriesInstanceUIDs: PropTypes.string,\r\n      dataset: PropTypes.string,\r\n      dicomStore: PropTypes.string,\r\n      location: PropTypes.string,\r\n      project: PropTypes.string,\r\n    }),\r\n  }),\r\n  location: PropTypes.any,\r\n};\r\n\r\nexport default ViewerRouting;\r\n","import React, { useEffect, useRef } from 'react';\r\nexport default function usePrevious(value) {\r\n  const ref = useRef();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n\r\n  return ref.current;\r\n}\r\n","class GoogleCloudApi {\r\n  setAccessToken(accessToken) {\r\n    if (!accessToken) console.error('Access token is empty');\r\n    this.accessToken = accessToken;\r\n  }\r\n\r\n  get fetchConfig() {\r\n    if (!this.accessToken) throw new Error('OIDC access_token is not set');\r\n    return {\r\n      method: 'GET',\r\n      headers: {\r\n        Authorization: 'Bearer ' + this.accessToken,\r\n      },\r\n    };\r\n  }\r\n\r\n  get urlBase() {\r\n    return this.healthcareApiEndpoint || 'https://healthcare.googleapis.com/v1beta1';\r\n  }\r\n\r\n  set urlBase(url) {\r\n    this.healthcareApiEndpoint = url;\r\n  }\r\n\r\n  get urlBaseProject() {\r\n    return this.urlBase + `/projects`;\r\n  }\r\n\r\n  getUrlBaseDicomWeb(project, location, dataset, dicomStore) {\r\n    return (\r\n      this.urlBase +\r\n      `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}/dicomWeb`\r\n    );\r\n  }\r\n\r\n  getUrlPath(project, location, dataset, dicomStore) {\r\n    `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}`;\r\n  }\r\n\r\n  async doRequest(urlStr, config = {}, params = {}) {\r\n    const url = new URL(urlStr);\r\n    let data = null;\r\n    url.search = new URLSearchParams(params);\r\n\r\n    try {\r\n      const response = await fetch(url, { ...this.fetchConfig, config });\r\n      try {\r\n        data = await response.json();\r\n      } catch (err) {}\r\n      if (response.status >= 200 && response.status < 300 && data != null) {\r\n        if (data.nextPageToken != null) {\r\n          params.pageToken = data.nextPageToken;\r\n          let subPage = await this.doRequest(urlStr, config, params);\r\n          for (let key in data) {\r\n            if (data.hasOwnProperty(key)) {\r\n              data[key] = data[key].concat(subPage.data[key]);\r\n            }\r\n          }\r\n        }\r\n        return {\r\n          isError: false,\r\n          status: response.status,\r\n          data,\r\n        };\r\n      } else {\r\n        return {\r\n          isError: true,\r\n          status: response.status,\r\n          message:\r\n            (data && data.error && data.error.message) || 'Unknown error',\r\n        };\r\n      }\r\n    } catch (err) {\r\n      if (data && data.error) {\r\n        return {\r\n          isError: true,\r\n          status: err.status,\r\n          message: err.response.data.error.message || 'Unspecified error',\r\n        };\r\n      }\r\n      return {\r\n        isError: true,\r\n        message: (err && err.message) || 'Oops! Something went wrong',\r\n      };\r\n    }\r\n  }\r\n\r\n  async loadProjects() {\r\n    return this.doRequest(\r\n      'https://cloudresourcemanager.googleapis.com/v1/projects'\r\n    );\r\n  }\r\n\r\n  async loadLocations(projectId) {\r\n    return this.doRequest(`${this.urlBaseProject}/${projectId}/locations`);\r\n  }\r\n\r\n  async loadDatasets(projectId, locationId) {\r\n    return this.doRequest(\r\n      `${this.urlBaseProject}/${projectId}/locations/${locationId}/datasets`\r\n    );\r\n  }\r\n\r\n  async loadDicomStores(dataset) {\r\n    return this.doRequest(`${this.urlBase}/${dataset}/dicomStores`);\r\n  }\r\n}\r\n\r\nexport default new GoogleCloudApi();\r\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\r\nimport { metadata, studies, utils, log } from '@ohif/core';\r\nimport usePrevious from '../customHooks/usePrevious';\r\n\r\nimport ConnectedViewer from './ConnectedViewer.js';\r\nimport PropTypes from 'prop-types';\r\nimport { extensionManager } from './../App.js';\r\nimport { useSnackbarContext } from '@ohif/ui';\r\n\r\n// Contexts\r\nimport AppContext from '../context/AppContext';\r\n\r\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\r\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\r\nconst { studyMetadataManager, makeCancelable } = utils;\r\n\r\nconst _promoteToFront = (list, value, searchMethod) => {\r\n  let response = [...list];\r\n  let promoted = false;\r\n  const index = response.findIndex(searchMethod.bind(undefined, value));\r\n\r\n  if (index > 0) {\r\n    const first = response.splice(index, 1);\r\n    response = [...first, ...response];\r\n  }\r\n\r\n  if (index >= 0) {\r\n    promoted = true;\r\n  }\r\n\r\n  return {\r\n    promoted,\r\n    data: response,\r\n  };\r\n};\r\n\r\n/**\r\n * Promote series to front if find found equivalent on filters object\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\r\n  let promoted = false;\r\n  // Promote only if no filter should be applied\r\n  if (!isFilterStrategy) {\r\n    _sortStudyDisplaySet(study, studyMetadata);\r\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\r\n  let promoted = false;\r\n  const queryParamsLength = Object.keys(filters).length;\r\n  const shouldPromoteToFront = queryParamsLength > 0;\r\n\r\n  if (shouldPromoteToFront) {\r\n    const { seriesInstanceUID } = filters;\r\n\r\n    const _seriesLookup = (valueToCompare, displaySet) => {\r\n      return displaySet.SeriesInstanceUID === valueToCompare;\r\n    };\r\n    const promotedResponse = _promoteToFront(\r\n      studyMetadata.getDisplaySets(),\r\n      seriesInstanceUID,\r\n      _seriesLookup\r\n    );\r\n\r\n    study.displaySets = promotedResponse.data;\r\n    promoted = promotedResponse.promoted;\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\n/**\r\n * Method to identify if query param (from url) was applied to given list\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\r\n  const { seriesInstanceUID } = filters;\r\n  let applied = true;\r\n  // skip in case no filter or no toast manager\r\n  if (!seriesInstanceUID) {\r\n    return applied;\r\n  }\r\n\r\n  const { series = [], displaySets = [] } = study;\r\n  const firstSeries = isFilterStrategy ? series[0] : displaySets[0];\r\n\r\n  if (!firstSeries || firstSeries.SeriesInstanceUID !== seriesInstanceUID) {\r\n    applied = false;\r\n  }\r\n\r\n  return applied;\r\n};\r\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\r\n  if (queryParamApplied) {\r\n    return;\r\n  }\r\n\r\n  const { show: showUserMessage = () => {} } = dialog;\r\n  showUserMessage({\r\n    message,\r\n  });\r\n};\r\n\r\nconst _addSeriesToStudy = (studyMetadata, series) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n  const study = studyMetadata.getData();\r\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\r\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\r\n  if (existingSeries) {\r\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\r\n  } else {\r\n    studyMetadata.addSeries(seriesMetadata);\r\n  }\r\n\r\n  studyMetadata.createAndAddDisplaySetsForSeries(\r\n    sopClassHandlerModules,\r\n    seriesMetadata\r\n  );\r\n\r\n  study.displaySets = studyMetadata.getDisplaySets();\r\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\r\n    Modality: series.Modality,\r\n  });\r\n\r\n  _updateStudyMetadataManager(study, studyMetadata);\r\n};\r\n\r\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\r\n  const { StudyInstanceUID } = study;\r\n\r\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\r\n    studyMetadataManager.add(studyMetadata);\r\n  }\r\n};\r\n\r\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n\r\n  if (!study.displaySets) {\r\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\r\n  }\r\n\r\n  if (study.derivedDisplaySets) {\r\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\r\n  }\r\n\r\n  studyMetadata.setDisplaySets(study.displaySets);\r\n};\r\n\r\nconst _sortStudyDisplaySet = (study, studyMetadata) => {\r\n  studyMetadata.sortDisplaySets(study.displaySets);\r\n};\r\n\r\nconst _thinStudyData = study => {\r\n  return {\r\n    StudyInstanceUID: study.StudyInstanceUID,\r\n    series: study.series.map(item => ({\r\n      SeriesInstanceUID: item.SeriesInstanceUID,\r\n    })),\r\n  };\r\n};\r\n\r\nfunction ViewerRetrieveStudyData({\r\n  server,\r\n  studyInstanceUIDs,\r\n  seriesInstanceUIDs,\r\n  clearViewportSpecificData,\r\n  setStudyData,\r\n}) {\r\n  // hooks\r\n  const [error, setError] = useState(false);\r\n  const [studies, setStudies] = useState([]);\r\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\r\n  const snackbarContext = useSnackbarContext();\r\n  const { appConfig = {} } = useContext(AppContext);\r\n  const {\r\n    filterQueryParam: isFilterStrategy = false,\r\n    maxConcurrentMetadataRequests,\r\n  } = appConfig;\r\n\r\n  let cancelableSeriesPromises;\r\n  let cancelableStudiesPromises;\r\n  /**\r\n   * Callback method when study is totally loaded\r\n   * @param {object} study study loaded\r\n   * @param {object} studyMetadata studyMetadata for given study\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const studyDidLoad = (study, studyMetadata, filters) => {\r\n    // User message\r\n    const promoted = _promoteList(\r\n      study,\r\n      studyMetadata,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n\r\n    // Clear viewport to allow new promoted one to be displayed\r\n    if (promoted) {\r\n      clearViewportSpecificData(0);\r\n    }\r\n\r\n    const isQueryParamApplied = _isQueryParamApplied(\r\n      study,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n    // Show message in case not promoted neither filtered but should to\r\n    _showUserMessage(\r\n      isQueryParamApplied,\r\n      'Query parameters were not applied. Using original series list for given study.',\r\n      snackbarContext\r\n    );\r\n\r\n    setStudies([...studies, study]);\r\n    setIsStudyLoaded(true);\r\n  };\r\n\r\n  /**\r\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\r\n   * @param {Array} studiesData Array of studies retrieved from server\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const processStudies = (studiesData, filters) => {\r\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\r\n      // Map studies to new format, update metadata manager?\r\n      const studies = studiesData.map(study => {\r\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\r\n        const studyMetadata = new OHIFStudyMetadata(\r\n          study,\r\n          study.StudyInstanceUID\r\n        );\r\n\r\n        _updateStudyDisplaySets(study, studyMetadata);\r\n        _updateStudyMetadataManager(study, studyMetadata);\r\n\r\n        // Attempt to load remaning series if any\r\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\r\n          loadRemainingSeries(studyMetadata)\r\n        )\r\n          .then(result => {\r\n            if (result && !result.isCanceled) {\r\n              studyDidLoad(study, studyMetadata, filters);\r\n            }\r\n          })\r\n          .catch(error => {\r\n            if (error && !error.isCanceled) {\r\n              setError(true);\r\n              log.error(error);\r\n            }\r\n          });\r\n\r\n        return study;\r\n      });\r\n\r\n      setStudies(studies);\r\n    }\r\n  };\r\n\r\n  const forceRerender = () => setStudies(studies => [...studies]);\r\n\r\n  const loadRemainingSeries = async studyMetadata => {\r\n    const { seriesLoader } = studyMetadata.getData();\r\n    if (!seriesLoader) return;\r\n\r\n    const loadNextSeries = async () => {\r\n      if (!seriesLoader.hasNext()) return;\r\n      const series = await seriesLoader.next();\r\n      _addSeriesToStudy(studyMetadata, series);\r\n      forceRerender();\r\n      return loadNextSeries();\r\n    };\r\n\r\n    const concurrentRequestsAllowed =\r\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\r\n    const promises = Array(concurrentRequestsAllowed)\r\n      .fill(null)\r\n      .map(loadNextSeries);\r\n\r\n    return await Promise.all(promises);\r\n  };\r\n\r\n  const loadStudies = async () => {\r\n    try {\r\n      const filters = {};\r\n      // Use the first, discard others\r\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\r\n\r\n      const retrieveParams = [server, studyInstanceUIDs];\r\n\r\n      if (seriesInstanceUID) {\r\n        filters.seriesInstanceUID = seriesInstanceUID;\r\n        // Query param filtering controlled by appConfig property\r\n        if (isFilterStrategy) {\r\n          retrieveParams.push(filters);\r\n        }\r\n      }\r\n\r\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\r\n        retrieveStudiesMetadata(...retrieveParams)\r\n      )\r\n        .then(result => {\r\n          if (result && !result.isCanceled) {\r\n            processStudies(result, filters);\r\n          }\r\n        })\r\n        .catch(error => {\r\n          if (error && !error.isCanceled) {\r\n            setError(true);\r\n            log.error(error);\r\n          }\r\n        });\r\n    } catch (error) {\r\n      if (error) {\r\n        setError(true);\r\n        log.error(error);\r\n      }\r\n    }\r\n  };\r\n\r\n  const purgeCancellablePromises = useCallback(() => {\r\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\r\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\r\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\r\n      }\r\n    }\r\n\r\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\r\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\r\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\r\n        deleteStudyMetadataPromise(studyInstanceUIDs);\r\n        studyMetadataManager.remove(studyInstanceUIDs);\r\n      }\r\n    }\r\n  });\r\n\r\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\r\n\r\n  useEffect(() => {\r\n    const hasStudyInstanceUIDsChanged = !(\r\n      prevStudyInstanceUIDs &&\r\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\r\n    );\r\n\r\n    if (hasStudyInstanceUIDsChanged) {\r\n      studyMetadataManager.purge();\r\n      purgeCancellablePromises();\r\n    }\r\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\r\n\r\n  useEffect(() => {\r\n    cancelableSeriesPromises = {};\r\n    cancelableStudiesPromises = {};\r\n    loadStudies();\r\n\r\n    return () => {\r\n      purgeCancellablePromises();\r\n    };\r\n  }, []);\r\n\r\n  if (error) {\r\n    return <div>Error: {JSON.stringify(error)}</div>;\r\n  }\r\n\r\n  return (\r\n    <ConnectedViewer\r\n      studies={studies}\r\n      isStudyLoaded={isStudyLoaded}\r\n      studyInstanceUIDs={studyInstanceUIDs}\r\n    />\r\n  );\r\n}\r\n\r\nViewerRetrieveStudyData.propTypes = {\r\n  studyInstanceUIDs: PropTypes.array.isRequired,\r\n  seriesInstanceUIDs: PropTypes.array,\r\n  server: PropTypes.object,\r\n  clearViewportSpecificData: PropTypes.func.isRequired,\r\n  setStudyData: PropTypes.func.isRequired,\r\n};\r\n\r\nexport default ViewerRetrieveStudyData;\r\n","import { connect } from 'react-redux';\r\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\r\nimport OHIF from '@ohif/core';\r\n\r\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\r\nconst isActive = a => a.active === true;\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n  const activeServer = state.servers.servers.find(isActive);\r\n\r\n  return {\r\n    server: ownProps.server || activeServer,\r\n  };\r\n};\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    setStudyData: (StudyInstanceUID, data) => {\r\n      dispatch(setStudyData(StudyInstanceUID, data));\r\n    },\r\n    clearViewportSpecificData: () => {\r\n      dispatch(clearViewportSpecificData());\r\n    },\r\n  };\r\n};\r\n\r\nconst ConnectedViewerRetrieveStudyData = connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps\r\n)(ViewerRetrieveStudyData);\r\n\r\nexport default ConnectedViewerRetrieveStudyData;\r\n","var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n","const getServers = (data, name) => {\r\n  const {\r\n    wadoUriRoot,\r\n    qidoRoot,\r\n    wadoRoot,\r\n    dataset = '',\r\n    dicomStore = '',\r\n    location = '',\r\n    project = '',\r\n  } = data;\r\n\r\n  return [\r\n    {\r\n      name: name,\r\n      dataset,\r\n      dicomStore,\r\n      location,\r\n      project,\r\n      imageRendering: 'wadors',\r\n      thumbnailRendering: 'wadors',\r\n      type: 'dicomWeb',\r\n      active: true,\r\n      wadoUriRoot,\r\n      qidoRoot,\r\n      wadoRoot,\r\n      supportsFuzzyMatching: false,\r\n      qidoSupportsIncludeField: false,\r\n    },\r\n  ];\r\n};\r\n\r\nconst isValidServer = server => {\r\n  return (\r\n    server &&\r\n    !!server.dataset &&\r\n    !!server.dicomStore &&\r\n    !!server.location &&\r\n    !!server.project\r\n  );\r\n};\r\n\r\nconst isEqualServer = (server = {}, toCompare = {}) => {\r\n  const serverLength = Object.keys(server).length;\r\n  const toCompareLength = Object.keys(toCompare).length;\r\n\r\n  if (!serverLength || !toCompareLength) {\r\n    return false;\r\n  }\r\n\r\n  return (\r\n    server.dataset === toCompare.dataset &&\r\n    server.dataset === toCompare.dataset &&\r\n    server.dicomStore === toCompare.dicomStore &&\r\n    server.location === toCompare.location &&\r\n    server.project === toCompare.project\r\n  );\r\n};\r\n\r\nexport { getServers, isValidServer, isEqualServer };\r\n","import React, { useContext } from 'react';\r\nimport GoogleCloudApi from '../googleCloud/api/GoogleCloudApi';\r\nimport usePrevious from './usePrevious';\r\n\r\nimport * as GoogleCloudUtilServers from '../googleCloud/utils/getServers';\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport isEqual from 'lodash.isequal';\r\n\r\n// Contexts\r\nimport AppContext from '../context/AppContext';\r\n\r\nconst getActiveServer = servers => {\r\n  const isActive = a => a.active === true;\r\n\r\n  return servers && servers.servers && servers.servers.find(isActive);\r\n};\r\n\r\nconst getServers = (appConfig, project, location, dataset, dicomStore) => {\r\n  let servers = [];\r\n  if (appConfig.enableGoogleCloudAdapter) {\r\n    GoogleCloudApi.urlBase = appConfig.healthcareApiEndpoint;\r\n    const pathUrl = GoogleCloudApi.getUrlBaseDicomWeb(\r\n      project,\r\n      location,\r\n      dataset,\r\n      dicomStore\r\n    );\r\n    const data = {\r\n      project,\r\n      location,\r\n      dataset,\r\n      dicomStore,\r\n      wadoUriRoot: pathUrl,\r\n      qidoRoot: pathUrl,\r\n      wadoRoot: pathUrl,\r\n    };\r\n    servers = GoogleCloudUtilServers.getServers(data, dicomStore);\r\n    if (!isValidServer(servers[0], appConfig)) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  return servers;\r\n};\r\n\r\nconst isValidServer = (server, appConfig) => {\r\n  if (appConfig.enableGoogleCloudAdapter) {\r\n    return GoogleCloudUtilServers.isValidServer(server);\r\n  }\r\n\r\n  return !!server;\r\n};\r\n\r\nconst setServers = (dispatch, servers) => {\r\n  const action = {\r\n    type: 'SET_SERVERS',\r\n    servers,\r\n  };\r\n  dispatch(action);\r\n};\r\n\r\nconst useServerFromUrl = (\r\n  servers = [],\r\n  previousServers,\r\n  activeServer,\r\n  urlBasedServers,\r\n  appConfig,\r\n  project,\r\n  location,\r\n  dataset,\r\n  dicomStore\r\n) => {\r\n  // update state from url available only when gcloud on\r\n  if (!appConfig.enableGoogleCloudAdapter) {\r\n    return false;\r\n  }\r\n\r\n  const serverHasChanged = previousServers !== servers && previousServers;\r\n\r\n  // do not update from url. use state instead.\r\n  if (serverHasChanged) {\r\n    return false;\r\n  }\r\n\r\n  // if no valid urlbased servers\r\n  if (!urlBasedServers || !urlBasedServers.length) {\r\n    return false;\r\n  } else if (!servers.length || !activeServer) {\r\n    // no current valid server\r\n    return true;\r\n  }\r\n\r\n  const newServer = urlBasedServers[0];\r\n\r\n  let exists = servers.some(\r\n    GoogleCloudUtilServers.isEqualServer.bind(undefined, newServer)\r\n  );\r\n\r\n  return !exists;\r\n};\r\n\r\nexport default function useServer({\r\n  project,\r\n  location,\r\n  dataset,\r\n  dicomStore,\r\n} = {}) {\r\n  // Hooks\r\n  const servers = useSelector(state => state && state.servers);\r\n  const previousServers = usePrevious(servers);\r\n  const dispatch = useDispatch();\r\n\r\n  const { appConfig = {} } = useContext(AppContext);\r\n\r\n  const activeServer = getActiveServer(servers);\r\n  const urlBasedServers =\r\n    getServers(appConfig, project, location, dataset, dicomStore) || [];\r\n  const shouldUpdateServer = useServerFromUrl(\r\n    servers.servers,\r\n    previousServers,\r\n    activeServer,\r\n    urlBasedServers,\r\n    appConfig,\r\n    project,\r\n    location,\r\n    dataset,\r\n    dicomStore\r\n  );\r\n\r\n  if (shouldUpdateServer) {\r\n    setServers(dispatch, urlBasedServers);\r\n  } else if (isValidServer(activeServer, appConfig)) {\r\n    return activeServer;\r\n  }\r\n}\r\n"],"sourceRoot":""}