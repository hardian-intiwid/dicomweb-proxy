{"version":3,"sources":["webpack:///./routes/IHEInvokeImageDisplay.js","webpack:///./customHooks/usePrevious.js","webpack:///C:/sandbox/Viewers/node_modules/lodash/_baseValues.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///C:/sandbox/Viewers/node_modules/lodash/values.js"],"names":["UrlUtil","OHIF","utils","urlUtil","IHEInvokeImageDisplay","location","parse","search","requestType","studyUID","studyInstanceUIDs","split","paramString","parseParam","propTypes","PropTypes","shape","string","isRequired","withRouter","usePrevious","value","ref","useRef","useEffect","current","arrayMap","module","exports","object","props","key","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_sortStudyDisplaySet","_promoteStudyDisplaySet","Object","keys","length","seriesInstanceUID","promotedResponse","list","searchMethod","response","index","findIndex","bind","undefined","first","splice","data","_promoteToFront","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","displaySets","_isQueryParamApplied","applied","series","firstSeries","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","createDisplaySets","_addDerivedDisplaySets","setDisplaySets","sortDisplaySets","_thinStudyData","map","item","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","seriesInstanceUIDs","clearViewportSpecificData","setStudyData","useState","error","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","log","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","every","e","includes","purge","JSON","stringify","ConnectedViewer","array","func","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch","baseValues"],"mappings":"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","file":"IHEInvokeImageDisplay.bundle.f4791b4b5d6e18887e25.js","sourcesContent":["import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { withRouter } from 'react-router-dom';\r\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData.js';\r\nimport OHIF from '@ohif/core';\r\nconst { urlUtil: UrlUtil } = OHIF.utils;\r\n\r\nfunction IHEInvokeImageDisplay({ location }) {\r\n  const {\r\n    // patientID,\r\n    requestType,\r\n    studyUID,\r\n  } = UrlUtil.parse(location.search);\r\n\r\n  switch (requestType) {\r\n    case 'STUDY':\r\n      return (\r\n        <ConnectedViewerRetrieveStudyData\r\n          studyInstanceUIDs={studyUID.split(';')}\r\n        />\r\n      );\r\n\r\n    case 'STUDYBASE64':\r\n      return (\r\n        <ConnectedViewerRetrieveStudyData\r\n          studyInstanceUIDs={UrlUtil.paramString.parseParam(studyUID)}\r\n        />\r\n      );\r\n\r\n    case 'PATIENT':\r\n      // TODO: connect this to the StudyList when we have the filter parameters set up\r\n      // return <StudyList patientUIDs={patientID.split(';')} />;\r\n      return '';\r\n\r\n    default:\r\n      // TODO: Figure out what to do here, this won't work because StudyList expects studies\r\n      // return <StudyList />;\r\n      return '';\r\n  }\r\n}\r\n\r\nIHEInvokeImageDisplay.propTypes = {\r\n  location: PropTypes.shape({\r\n    search: PropTypes.string,\r\n  }).isRequired,\r\n};\r\n\r\nexport default withRouter(IHEInvokeImageDisplay);\r\n","import React, { useEffect, useRef } from 'react';\r\nexport default function usePrevious(value) {\r\n  const ref = useRef();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n\r\n  return ref.current;\r\n}\r\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\r\nimport { metadata, studies, utils, log } from '@ohif/core';\r\nimport usePrevious from '../customHooks/usePrevious';\r\n\r\nimport ConnectedViewer from './ConnectedViewer.js';\r\nimport PropTypes from 'prop-types';\r\nimport { extensionManager } from './../App.js';\r\nimport { useSnackbarContext } from '@ohif/ui';\r\n\r\n// Contexts\r\nimport AppContext from '../context/AppContext';\r\n\r\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\r\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\r\nconst { studyMetadataManager, makeCancelable } = utils;\r\n\r\nconst _promoteToFront = (list, value, searchMethod) => {\r\n  let response = [...list];\r\n  let promoted = false;\r\n  const index = response.findIndex(searchMethod.bind(undefined, value));\r\n\r\n  if (index > 0) {\r\n    const first = response.splice(index, 1);\r\n    response = [...first, ...response];\r\n  }\r\n\r\n  if (index >= 0) {\r\n    promoted = true;\r\n  }\r\n\r\n  return {\r\n    promoted,\r\n    data: response,\r\n  };\r\n};\r\n\r\n/**\r\n * Promote series to front if find found equivalent on filters object\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\r\n  let promoted = false;\r\n  // Promote only if no filter should be applied\r\n  if (!isFilterStrategy) {\r\n    _sortStudyDisplaySet(study, studyMetadata);\r\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\r\n  let promoted = false;\r\n  const queryParamsLength = Object.keys(filters).length;\r\n  const shouldPromoteToFront = queryParamsLength > 0;\r\n\r\n  if (shouldPromoteToFront) {\r\n    const { seriesInstanceUID } = filters;\r\n\r\n    const _seriesLookup = (valueToCompare, displaySet) => {\r\n      return displaySet.SeriesInstanceUID === valueToCompare;\r\n    };\r\n    const promotedResponse = _promoteToFront(\r\n      studyMetadata.getDisplaySets(),\r\n      seriesInstanceUID,\r\n      _seriesLookup\r\n    );\r\n\r\n    study.displaySets = promotedResponse.data;\r\n    promoted = promotedResponse.promoted;\r\n  }\r\n\r\n  return promoted;\r\n};\r\n\r\n/**\r\n * Method to identify if query param (from url) was applied to given list\r\n * @param {Object} study - study reference to promote series against\r\n * @param {Object} [filters] - Object containing filters to be applied\r\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\r\n */\r\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\r\n  const { seriesInstanceUID } = filters;\r\n  let applied = true;\r\n  // skip in case no filter or no toast manager\r\n  if (!seriesInstanceUID) {\r\n    return applied;\r\n  }\r\n\r\n  const { series = [], displaySets = [] } = study;\r\n  const firstSeries = isFilterStrategy ? series[0] : displaySets[0];\r\n\r\n  if (!firstSeries || firstSeries.SeriesInstanceUID !== seriesInstanceUID) {\r\n    applied = false;\r\n  }\r\n\r\n  return applied;\r\n};\r\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\r\n  if (queryParamApplied) {\r\n    return;\r\n  }\r\n\r\n  const { show: showUserMessage = () => {} } = dialog;\r\n  showUserMessage({\r\n    message,\r\n  });\r\n};\r\n\r\nconst _addSeriesToStudy = (studyMetadata, series) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n  const study = studyMetadata.getData();\r\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\r\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\r\n  if (existingSeries) {\r\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\r\n  } else {\r\n    studyMetadata.addSeries(seriesMetadata);\r\n  }\r\n\r\n  studyMetadata.createAndAddDisplaySetsForSeries(\r\n    sopClassHandlerModules,\r\n    seriesMetadata\r\n  );\r\n\r\n  study.displaySets = studyMetadata.getDisplaySets();\r\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\r\n    Modality: series.Modality,\r\n  });\r\n\r\n  _updateStudyMetadataManager(study, studyMetadata);\r\n};\r\n\r\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\r\n  const { StudyInstanceUID } = study;\r\n\r\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\r\n    studyMetadataManager.add(studyMetadata);\r\n  }\r\n};\r\n\r\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\r\n  const sopClassHandlerModules =\r\n    extensionManager.modules['sopClassHandlerModule'];\r\n\r\n  if (!study.displaySets) {\r\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\r\n  }\r\n\r\n  if (study.derivedDisplaySets) {\r\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\r\n  }\r\n\r\n  studyMetadata.setDisplaySets(study.displaySets);\r\n};\r\n\r\nconst _sortStudyDisplaySet = (study, studyMetadata) => {\r\n  studyMetadata.sortDisplaySets(study.displaySets);\r\n};\r\n\r\nconst _thinStudyData = study => {\r\n  return {\r\n    StudyInstanceUID: study.StudyInstanceUID,\r\n    series: study.series.map(item => ({\r\n      SeriesInstanceUID: item.SeriesInstanceUID,\r\n    })),\r\n  };\r\n};\r\n\r\nfunction ViewerRetrieveStudyData({\r\n  server,\r\n  studyInstanceUIDs,\r\n  seriesInstanceUIDs,\r\n  clearViewportSpecificData,\r\n  setStudyData,\r\n}) {\r\n  // hooks\r\n  const [error, setError] = useState(false);\r\n  const [studies, setStudies] = useState([]);\r\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\r\n  const snackbarContext = useSnackbarContext();\r\n  const { appConfig = {} } = useContext(AppContext);\r\n  const {\r\n    filterQueryParam: isFilterStrategy = false,\r\n    maxConcurrentMetadataRequests,\r\n  } = appConfig;\r\n\r\n  let cancelableSeriesPromises;\r\n  let cancelableStudiesPromises;\r\n  /**\r\n   * Callback method when study is totally loaded\r\n   * @param {object} study study loaded\r\n   * @param {object} studyMetadata studyMetadata for given study\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const studyDidLoad = (study, studyMetadata, filters) => {\r\n    // User message\r\n    const promoted = _promoteList(\r\n      study,\r\n      studyMetadata,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n\r\n    // Clear viewport to allow new promoted one to be displayed\r\n    if (promoted) {\r\n      clearViewportSpecificData(0);\r\n    }\r\n\r\n    const isQueryParamApplied = _isQueryParamApplied(\r\n      study,\r\n      filters,\r\n      isFilterStrategy\r\n    );\r\n    // Show message in case not promoted neither filtered but should to\r\n    _showUserMessage(\r\n      isQueryParamApplied,\r\n      'Query parameters were not applied. Using original series list for given study.',\r\n      snackbarContext\r\n    );\r\n\r\n    setStudies([...studies, study]);\r\n    setIsStudyLoaded(true);\r\n  };\r\n\r\n  /**\r\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\r\n   * @param {Array} studiesData Array of studies retrieved from server\r\n   * @param {Object} [filters] - Object containing filters to be applied\r\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\r\n   */\r\n  const processStudies = (studiesData, filters) => {\r\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\r\n      // Map studies to new format, update metadata manager?\r\n      const studies = studiesData.map(study => {\r\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\r\n        const studyMetadata = new OHIFStudyMetadata(\r\n          study,\r\n          study.StudyInstanceUID\r\n        );\r\n\r\n        _updateStudyDisplaySets(study, studyMetadata);\r\n        _updateStudyMetadataManager(study, studyMetadata);\r\n\r\n        // Attempt to load remaning series if any\r\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\r\n          loadRemainingSeries(studyMetadata)\r\n        )\r\n          .then(result => {\r\n            if (result && !result.isCanceled) {\r\n              studyDidLoad(study, studyMetadata, filters);\r\n            }\r\n          })\r\n          .catch(error => {\r\n            if (error && !error.isCanceled) {\r\n              setError(true);\r\n              log.error(error);\r\n            }\r\n          });\r\n\r\n        return study;\r\n      });\r\n\r\n      setStudies(studies);\r\n    }\r\n  };\r\n\r\n  const forceRerender = () => setStudies(studies => [...studies]);\r\n\r\n  const loadRemainingSeries = async studyMetadata => {\r\n    const { seriesLoader } = studyMetadata.getData();\r\n    if (!seriesLoader) return;\r\n\r\n    const loadNextSeries = async () => {\r\n      if (!seriesLoader.hasNext()) return;\r\n      const series = await seriesLoader.next();\r\n      _addSeriesToStudy(studyMetadata, series);\r\n      forceRerender();\r\n      return loadNextSeries();\r\n    };\r\n\r\n    const concurrentRequestsAllowed =\r\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\r\n    const promises = Array(concurrentRequestsAllowed)\r\n      .fill(null)\r\n      .map(loadNextSeries);\r\n\r\n    return await Promise.all(promises);\r\n  };\r\n\r\n  const loadStudies = async () => {\r\n    try {\r\n      const filters = {};\r\n      // Use the first, discard others\r\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\r\n\r\n      const retrieveParams = [server, studyInstanceUIDs];\r\n\r\n      if (seriesInstanceUID) {\r\n        filters.seriesInstanceUID = seriesInstanceUID;\r\n        // Query param filtering controlled by appConfig property\r\n        if (isFilterStrategy) {\r\n          retrieveParams.push(filters);\r\n        }\r\n      }\r\n\r\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\r\n        retrieveStudiesMetadata(...retrieveParams)\r\n      )\r\n        .then(result => {\r\n          if (result && !result.isCanceled) {\r\n            processStudies(result, filters);\r\n          }\r\n        })\r\n        .catch(error => {\r\n          if (error && !error.isCanceled) {\r\n            setError(true);\r\n            log.error(error);\r\n          }\r\n        });\r\n    } catch (error) {\r\n      if (error) {\r\n        setError(true);\r\n        log.error(error);\r\n      }\r\n    }\r\n  };\r\n\r\n  const purgeCancellablePromises = useCallback(() => {\r\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\r\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\r\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\r\n      }\r\n    }\r\n\r\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\r\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\r\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\r\n        deleteStudyMetadataPromise(studyInstanceUIDs);\r\n        studyMetadataManager.remove(studyInstanceUIDs);\r\n      }\r\n    }\r\n  });\r\n\r\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\r\n\r\n  useEffect(() => {\r\n    const hasStudyInstanceUIDsChanged = !(\r\n      prevStudyInstanceUIDs &&\r\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\r\n    );\r\n\r\n    if (hasStudyInstanceUIDsChanged) {\r\n      studyMetadataManager.purge();\r\n      purgeCancellablePromises();\r\n    }\r\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\r\n\r\n  useEffect(() => {\r\n    cancelableSeriesPromises = {};\r\n    cancelableStudiesPromises = {};\r\n    loadStudies();\r\n\r\n    return () => {\r\n      purgeCancellablePromises();\r\n    };\r\n  }, []);\r\n\r\n  if (error) {\r\n    return <div>Error: {JSON.stringify(error)}</div>;\r\n  }\r\n\r\n  return (\r\n    <ConnectedViewer\r\n      studies={studies}\r\n      isStudyLoaded={isStudyLoaded}\r\n      studyInstanceUIDs={studyInstanceUIDs}\r\n    />\r\n  );\r\n}\r\n\r\nViewerRetrieveStudyData.propTypes = {\r\n  studyInstanceUIDs: PropTypes.array.isRequired,\r\n  seriesInstanceUIDs: PropTypes.array,\r\n  server: PropTypes.object,\r\n  clearViewportSpecificData: PropTypes.func.isRequired,\r\n  setStudyData: PropTypes.func.isRequired,\r\n};\r\n\r\nexport default ViewerRetrieveStudyData;\r\n","import { connect } from 'react-redux';\r\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\r\nimport OHIF from '@ohif/core';\r\n\r\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\r\nconst isActive = a => a.active === true;\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n  const activeServer = state.servers.servers.find(isActive);\r\n\r\n  return {\r\n    server: ownProps.server || activeServer,\r\n  };\r\n};\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    setStudyData: (StudyInstanceUID, data) => {\r\n      dispatch(setStudyData(StudyInstanceUID, data));\r\n    },\r\n    clearViewportSpecificData: () => {\r\n      dispatch(clearViewportSpecificData());\r\n    },\r\n  };\r\n};\r\n\r\nconst ConnectedViewerRetrieveStudyData = connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps\r\n)(ViewerRetrieveStudyData);\r\n\r\nexport default ConnectedViewerRetrieveStudyData;\r\n","var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n"],"sourceRoot":""}